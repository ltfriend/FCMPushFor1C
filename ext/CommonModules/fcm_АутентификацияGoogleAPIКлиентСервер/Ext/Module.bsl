///////////////////////////////////////////////////////////////////////////////////////////////////////
// (с) Tolkachev Pavel, 2021
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
///////////////////////////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Отправляет серверу Google данные для аутентификации сервиса и возврашает ключ доступа (access token) для возможности
// отправлять запросы к Google API. В случае возникновения ошибки или передачи неверных данных будет вызвано Исключение.
//
// Параметры:
//  СекретныйКлюч - Строка - строка в формате JSON, содержащая данные секретного ключа.
//  Разрешения - Строка - разрешения, необходимые для доступа к Google API.
//  ПутьКOpenSsl - Строка - строка к каталогу программы OpenSsl, которая используется для создания подписи отправляемого
//                          JSON Web Token.
// 
// Возвращаемое значение:
//  Строка - ключ доступа к Google API.
//
Функция ПолучитьКлючДоступаGoogleAPI(СекретныйКлюч, Разрешения, Знач ПутьКOpenSsl) Экспорт
	
	Если Прав(ПутьКOpenSsl, 1) <> "\" Тогда
		ПутьКOpenSsl = ПутьКOpenSsl + "\";
	КонецЕсли; 
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	
	ПараметрыЗапроса = СтрШаблон("{""grant_type"":""%1"",""assertion"":""%2""}",
		"urn:ietf:params:oauth:grant-type:jwt-bearer",
		СформироватьJWT(СекретныйКлюч, Разрешения, ПутьКOpenSsl)
	);
	
	Запрос = Новый HTTPЗапрос("token", Заголовки);
	Запрос.УстановитьТелоИзСтроки(ПараметрыЗапроса);
	
	Соединение = Новый HTTPСоединение(
		АдресСервераАутентификацииGoogle(), , , , , ,
		Новый ЗащищенноеСоединениеOpenSSL
	);
	Ответ = Соединение.ОтправитьДляОбработки(Запрос);
	
	ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	
	Если Не ПустаяСтрока(ТелоОтвета) Тогда
		
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(ТелоОтвета);
		
		СтруктураОтвета = ПрочитатьJSON(ЧтениеJSON);
		
		ЧтениеJSON.Закрыть();
		
	Иначе
		
		СтруктураОтвета = Неопределено;
		
	КонецЕсли; 
	
	Если Ответ.КодСостояния <> 200 Тогда
		
		ИнформацияОбОшибке = ?(СтруктураОтвета <> Неопределено,
			СтруктураОтвета,
			Новый Структура
		);
		ИнформацияОбОшибке.Вставить("КодСостояния", Ответ.КодСостояния);
		ВызватьИсключение СформироватьОписаниеОшибкиGoogleAPI(ИнформацияОбОшибке);
		
	КонецЕсли; 
	
	Возврат СтруктураОтвета.access_token;
	
КонецФункции 

#КонецОбласти 

#Область СлужебныеПроцедурыИФункции

#Область ФормированиеJSONWebToken

// Выполняет формирование JSON Web Token (JWT), который необходимо отправить для аутентификации.
//
// Параметры:
//  СекретныйКлюч - Строка - строка в формате JSON, содержащая данные секретного ключа.
//  Разрешения - Строка - разрешения, необходимые для доступа к Google API.
//  ПутьКOpenSsl - Строка - строка к каталогу программы OpenSsl, которая используется для создания подписи отправляемого
//                          JSON Web Token.
// 
// Возвращаемое значение:
//  Строка - JSON Web Token в строке формата Base64, подписанный секретным ключом.
//
Функция СформироватьJWT(СекретныйКлюч, Разрешения, ПутьКOpenSsl)
	
	СтруктураКлюча = СекретныйКлючJSONВСтруктуру(СекретныйКлюч);
	
	ЗаголовокJWT = СформироватьЗаголовокJWT();
	ТелоJWT = СформироватьТелоJWT(СтруктураКлюча, Разрешения);
	
	ПодписываемаяСтрока = ЗаголовокJWT + "." + ТелоJWT;
	Подпись = ПодписатьJWT(ПодписываемаяСтрока, СтруктураКлюча.private_key, ПутьКOpenSsl);
	
	JWT = ЗаголовокJWT + "." + ТелоJWT + "." + Подпись;
	Возврат JWT;
	
КонецФункции 

// Формирует заголовок JSON Web Token (JWT). Заголовок содержит алгортим подписи (RS256) и тип токена (JWT).
// 
// Возвращаемое значение:
//  Строка - заголовок JSON Web Token в строке формата Base64.
//
Функция СформироватьЗаголовокJWT()
	
	ЗаголовокJWT = "{""alg"":""RS256"",""typ"":""JWT""}";
	Возврат СтрокаВСтрокуBase64(ЗаголовокJWT);
	
КонецФункции 

// Формирует тело JSON Web Token (JWT) в формате JSON. Тело содержит идентификатор сервиса, разрешения, срок действия
// ключа доступа (устанавливается максимально возможное значение - 1 ч) и другие параметры.
//
// Параметры:
//  СекретныйКлюч - Структура - данные секретного ключа, по которому формируется тело JSON Web Token.
//  Разрешения - Строка - разрешения, необходимые для доступа к Google API.
// 
// Возвращаемое значение:
//  Строка - тело JSON Web Token в строке формата Base64.
//
Функция СформироватьТелоJWT(СекретныйКлюч, Разрешения)
	
	СекундВЧасе = 3600;
	ДатаВыдачи = ДатаВДатуUnix(ТекущаяУниверсальнаяДатаСервера());
	ДатаОкончания = ДатаВыдачи + СекундВЧасе;
	
	ШаблонТела =
	"{
	|	""iss"": ""%1"",
	|	""scope"": ""%2"",
	|	""aud"": ""%3"",
	|	""exp"": %4,
	|	""iat"": %5
	|}";
	Тело = СтрШаблон(ШаблонТела,
		СекретныйКлюч.client_email,
		Разрешения,
		СекретныйКлюч.token_uri,
		Формат(ДатаОкончания, "ЧГ="),
		Формат(ДатаВыдачи, "ЧГ="));
		
	Возврат СтрокаВСтрокуBase64(Тело);
	
КонецФункции 

// Выполняет подписание JSON Web Token секретным ключом с использованием программы OpenSsl и возвращает сформированную
// подпись.
//
// Параметры:
//  JWT - Строка - строка в формате Base64, сформированная из заголовка и тела JSON Web Token, которая будет подписана
//                 секретным ключом.
//  СекретныйКлюч - Строка - секретный ключ (private key), используемый для подписания JSON Web Token.
//  ПутьКOpenSsl - Строка - строка к каталогу программы OpenSsl, которая используется для создания подписи JSON Web Token.
// 
// Возвращаемое значение:
//  Строка - подпись JSON Web Token в строке формата Base64.
//
Функция ПодписатьJWT(JWT, СекретныйКлюч, ПутьКOpenSsl)
	
	КаталогФайлов = ПолучитьИмяВременногоФайла();
	СоздатьКаталог(КаталогФайлов);
	
	ИмяФайлаКлюча = КаталогФайлов + "\private.key";
	ИмяФайлаJWT = КаталогФайлов + "\jwt.txt";
	ИмяФайлаПодписи = КаталогФайлов + "\jwt.sgn";
	
	ЗаписатьСтрокуВФайл(JWT, ИмяФайлаJWT);
	ЗаписатьСтрокуВФайл(СекретныйКлюч, ИмяФайлаКлюча);
	
	OpenSsl = ПутьКOpenSsl + "openssl.exe";
	СтрокаКоманды = OpenSsl + " dgst -sha256 -sign " + ИмяФайлаКлюча + " -out " + ИмяФайлаПодписи + " " + ИмяФайлаJWT;
	КодВозврата = Неопределено;
	
	ЗапуститьПриложение(СтрокаКоманды, , Истина, КодВозврата);
	
	Если КодВозврата <> 0 Тогда
		УдалитьФайлы(КаталогФайлов);
		ВызватьИсключение СтрШаблон(
			НСтр("ru='Произошла ошибка при подписании JSON Web Token. Код возврата: %1'"),
			КодВозврата);
	КонецЕсли; 
	
	ДанныеПодписи = Новый ДвоичныеДанные(ИмяФайлаПодписи);
	
	УдалитьФайлы(КаталогФайлов);
	
	Возврат Base64СтрокаБезРазделителей(ДанныеПодписи);
	
КонецФункции 

// Записывает строку в файл для использования в программе OpenSsl.
//
// Параметры:
//  Строка - Строка - строка, которую необходимо записать в файл.
//  ИмяФайла - Строка - имя файла, в который будет записана строка.
//
Процедура ЗаписатьСтрокуВФайл(Строка, ИмяФайла)
	
	// Используется поток, чтобы записать текст в формате UTF-8 без BOM.
	Поток = Новый ПотокВПамяти;
	
	ЗаписьТекста = Новый ЗаписьТекста(Поток, КодировкаТекста.UTF8, , , Ложь);
	ЗаписьТекста.Записать(Строка);
	ЗаписьТекста.Закрыть();
	
	ДвоичныеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	ДвоичныеДанные.Записать(ИмяФайла);
	
КонецПроцедуры 

#КонецОбласти 

#Область Прочее

// Удаляет из строки формата Base64 разделители ВК + ПС.
//
// Параметры:
//  Значение - Строка - строка формата Base64.
// 
// Возвращаемое значение:
//  Строка - строка формата Base64 без разделителей ВК + ПС.
//
Функция Base64СтрокаБезРазделителей(Значение)
	
	Результат = Base64Строка(Значение);
	Возврат СтрЗаменить(Результат, Символы.ВК + Символы.ПС, "");
	
КонецФункции 

// Преобразует дату 1С в дату формата Unix (количество секунд, прошедших с 01.01.1970).
//
// Параметры:
//  Дата - Дата - дата, которую необходимо преобразовать в формат Unix.
// 
// Возвращаемое значение:
//  Число - дата в формате Unix (количество секунд, прошедших с 01.01.1970).
//
Функция ДатаВДатуUnix(Дата)
	
	Возврат Дата - '19700101';
	
КонецФункции 

// Преобразует секретный ключ из строки в формате JSON в структуру.
//
// Параметры:
//  СекретныйКлюч - Строка - строка в формате JSON, содержащая данные секретного ключа.
// 
// Возвращаемое значение:
//  Структура - данные секретного ключа, преобразованные из строки в формате JSON.
//
Функция СекретныйКлючJSONВСтруктуру(СекретныйКлюч)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СекретныйКлюч);
	
	Результат = ПрочитатьJSON(ЧтениеJSON);
	
	ЧтениеJSON.Закрыть();
	
	Возврат Результат;
	
КонецФункции 

// Преобразует строку в строку формата Base64.
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка, которую необходимо преобразовать в строку формата Base64.
// 
// Возвращаемое значение:
//  Строка - строка, преобразованная в строку формата Base64.
//
Функция СтрокаВСтрокуBase64(ИсходнаяСтрока)
	
	Поток = Новый ПотокВПамяти;
	
	ЗаписьТекста = Новый ЗаписьТекста(Поток, КодировкаТекста.UTF8);
	ЗаписьТекста.Записать(ИсходнаяСтрока);
	ЗаписьТекста.Закрыть();
	
	ДвоичныеДанные = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	Возврат Base64СтрокаБезРазделителей(ДвоичныеДанные);
	
КонецФункции 

// Возвращает описание ошибки Google API из HTTP ответа для отображения пользователю.
//
// Параметры:
//  ИнформацияОбОшибке - Структура - информация об ошибке, полученной их HTTP ответа.
// 
// Возвращаемое значение:
//  Строка - описание ошибки Google API из HTTP ответа для отображения пользователю.
//
Функция СформироватьОписаниеОшибкиGoogleAPI(ИнформацияОбОшибке)
	
	ОписаниеОшибки = "";
	
	Если ИнформацияОбОшибке.Свойство("error_description") Тогда
		ОписаниеОшибки = ИнформацияОбОшибке.error_description;
	КонецЕсли; 
	
	Если ИнформацияОбОшибке.Свойство("error") Тогда
		ОписаниеОшибки = ?(ПустаяСтрока(ОписаниеОшибки),
			ИнформацияОбОшибке.error,
			"(" + ИнформацияОбОшибке.error + ") " + ОписаниеОшибки
		);
	КонецЕсли; 
	
	ТекстСообщения = НСтр("ru='Ошибка при получении ключа доступа Google API'");
	ТекстСообщения = ТекстСообщения + ?(Не ПустаяСтрока(ОписаниеОшибки),
		": " + ОписаниеОшибки,
		НСтр("ru='. Код состояния: '") + ИнформацияОбОшибке.КодСостояния + "."
	);
		
	Возврат ТекстСообщения;
	
КонецФункции 

// Возвращает текущую универсальную дата (UTC). Так как данную дату можно получить только на сервере, то на клиенте
// используется вызов сервера.
// 
// Возвращаемое значение:
//  Дата - текущая универсальная дата (UTC).
//
Функция ТекущаяУниверсальнаяДатаСервера()
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Возврат ТекущаяУниверсальнаяДата();
#Иначе
	Возврат fcm_СлужебныйВызовСервера.ТекущаяУниверсальнаяДатаСервера();
#КонецЕсли

КонецФункции 

Функция АдресСервераАутентификацииGoogle()
	Возврат "oauth2.googleapis.com";
КонецФункции 

#КонецОбласти 

#КонецОбласти